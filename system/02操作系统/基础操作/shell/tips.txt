数据流重定向
UNIX 有几种输入输出流，它们分别与几个数字有如下的对应关系：
0-标准输入流(stdin)
1-标准输出流(stdout)
2-标准错误流(stderr)
"2>&1" 的意思就是将 stderr 重定向至 stdout 并一起在屏幕上显示出来。
如果不加数字，那么默认的重定向动作是针对 stdout(1) 的。
举例说明：
cat std.sh
#!/bin/sh
echo "stdout"
echo "stderr" >&2

/bin/sh std.sh 2>&1 > /dev/null
输出结果是 stderr ，因为 stdout 和 stderr 合并后一同重定向到 /dev/null ，但 stderr 并未被清除，因此仍将在屏幕中显示出来。

/bin/sh std.sh > /dev/null 2>&1
无输出，因为当 stdout 重定向至 /dev/null 后， stderr 又重定向到了 stdout ，这样 stderr 也被输出到了/dev/null 。


统计一个目录下子目录内的文件数量
for x in `ls -l /home/xnjcw_branch/test/template_1 | grep ^d | awk '{print $9}'` ; do
dir="/home/xnjcw_branch/test/template_1/"$x
i=`ls -l $dir | wc -l`
let "i=i-1"
echo $dir >> ~/nums.txt
echo $i >> ~/nums.txt
done


删除2004年的文件
unset LANG
ls -l | awk '{print $8,$9}' | grep ^2004 | awk '{print $2}' | xargs rm


统计一个目录下子目录的大小
#!/bin/sh

dir=$1

ls -l $dir | awk '{print $9}' | while read x; do
du -sm $dir/$x >> spaces.txt
done


记录两个文件相同的行
#!/bin/bash

while read x ; do
  while read i ; do
    if [ $x == $i ]
    then
      echo $x >> tmp.txt
      braek
    fi
  done < backup.txt
done < other.txt


统计一个目录下以"_"分隔的不同前缀名文件的数目
ll | awk '{print $9}' | cut -d _ -f 1 | uniq -c